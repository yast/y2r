Y2R
===

Y2R is a transpiler translating
[YCP](http://doc.opensuse.org/projects/YaST/SLES10/tdg/Book-YCPLanguage.html) (a
legacy language used to write parts of
[YaST](http://en.opensuse.org/Portal:YaST)) into Ruby. It was used to translate
YCP-based parts of the YaST codebase into Ruby, which will allow us to get rid
of YCP completely.

The translation itself is described by a
[specification](https://github.com/yast/y2r/blob/master/spec/y2r_spec.md).

Installation
------------

Y2R is tested only on [openSUSE 12.3](http://en.opensuse.org/Portal:12.3). It
probably won't work in other openSUSE versions, other Linux distributions, or
other operating systems.

The following steps will make YCP Killer run on a vanilla openSUSE 12.3 system.

  1. **Install Git**

         $ sudo zypper in git

  2. **Update `ycpc`**

     Updated `ycpc` is needed because Y2R uses it internally and it relies on
     some features that are not present in `ycpc` bundled with openSUSE 12.3.

     To install updated `ycpc`, install the `yast2-core` package from
     `YaST:Head`:

         $ sudo zypper ar -f \
             http://download.opensuse.org/repositories/YaST:/Head/openSUSE_12.3/ \
             YaST:Head
         $ sudo zypper in -f -r YaST:Head yast2-core

  3. **Install basic Ruby environment**

         $ sudo zypper in ruby ruby-devel

  4. **Install Y2R's dependencies**

         $ sudo zypper in gcc-c++ make libxml2-devel libxslt-devel   # Needed by Nokogiri

  5. **Install Y2R**

         $ sudo gem install y2r

  6. **Done!**

     You can now start using Y2R.

Usage
-----

Y2R is a command-line tool. You can invoke it using the `y2r` command. Its
syntax looks like this:

    y2r [options] [<ycp_file>] [<ruby_file>]

Y2R reads YCP code from `ycp_file`, generates Ruby code from it and writes it to
`ruby_file`. If `ruby_file` is omitted, its name is generated by changing
`ycp_file` extension to `.rb`. If both `ycp_file` and `ruby_file` are omitted,
standard input and output are used.

### Options

Y2R supports the following options:

  * **-I, --include-path \<path\>**

    Path where to find included files. Can be specified multiple times.

    Paths specified using this option are passed to `ycpc`, which is invoked as
    part of the compilation.

  * **-M, --module-path \<path\>**

    Path where to find modules. Can be specified multiple times.

    Paths specified using this option are passed to `ycpc`, which is invoked as
    part of the compilation.

  * **--export-private**

    Export also private symbols from translated modules.

    This option is needed because testuites of some YaST modules access also
    private symbols of various YCP modules. As a result, these YCP modules need
    to be translated with `--export-private`.

  * **--as-include-file**

    Compile as include file.

    This option is needed because there is no way to tell a YCP containing a
    client from one containing an include.

  * **--extract-file \<file\>**

    Compile only code of specified include file.

    This option is useful when you need to compile an include file which is not
    standalone. The solution is to compile it in context of some other file
    (which supplies symbols the include depends on) and use `--extract-file` to
    make sure code corresponding to the include is emitted instead of code
    corresponding to the wrapping file.

    The file needs to be specified in exactly the same way as in the `include`
    statement in the wrapping file. For example, if the wrapping file contains

        include "packages/common.ycp"

    you need to specify `--extract-file packages/common.ycp`.

  * **--report-file \<file\>**

    Report specified file as the compiled one.

    The reported file is used to construct some class names in generated code.

  * **--xml**

    Print just XML emitted by `ycpc`.

    This option is useful mainly for debugging.

  * **--version**

    Print version information and exit.

  * **--help**

    Print help and exit.

Known Issues
------------

  * The code quality isn't optimal in many places. This was caused by very short
    development time with little room for refactoring and cleanups. Given that
    Y2R will be used just once and then mostly forgotten, this is not a big
    deal.
