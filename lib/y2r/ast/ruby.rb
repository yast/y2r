# encoding: utf-8

require "ostruct"

module Y2R
  module AST
    # Classes in this module represent Ruby AST nodes. Their main task is to
    # serialize themselves into readable Ruby code using the |to_ruby| method.
    #
    # Note that these classes can't represent the whole Ruby language, only
    # parts actually generated by Y2R.
    module Ruby
      # Code-related utilities.
      module Code
        class << self
          def multi_line?(code)
            !code.index("\n").nil?
          end
        end
      end

      # Operator priorities.
      #
      # Note the table is incomplete (because the AST is incomplete).
      module Priority
        ATOMIC         = 15   # atomic expressions (e.g. literals)
        UNARY          = 14   # !, ~, + (unary)
        POWER          = 13   # **
        UNARY_MINUS    = 12   # - (unary)
        MULTIPLY       = 11   # *, /, %
        ADD            = 10   # +, -
        SHIFT          = 9    # <<, >>
        BITWISE_AND    = 8    # &
        BITWISE_OR     = 7    # |, ^
        COMPARE        = 6    # >, >=, <, <=
        EQUAL          = 5    # <=>, ==, ===, !=, =~, !~
        LOGICAL_AND    = 4    # &&
        LOGICAL_OR     = 3    # ||
        TERNARY        = 2    # ? :
        ASSIGNMENT     = 1    # =
        NONE           = 0    # lowest priority, nothing needs to be in parens
      end

      # Context passed to the #to_ruby and related methods on nodes.
      class EmitterContext < OpenStruct
        def indented(n)
          context = dup
          context.width -= n
          context.shift = 0
          context
        end

        def shifted(n)
          context = dup
          context.shift += n
          context
        end

        def with_priority(priority)
          context = dup
          context.priority = priority
          context
        end

        def with_max_key_width(max_key_width)
          context = dup
          context.max_key_width = max_key_width
          context
        end

        def without_max_key_width
          context = dup
          context.max_key_width = nil
          context
        end

        def with_trailer(trailer)
          context = dup
          context.trailer = trailer
          context
        end

        def without_trailer
          context = dup
          context.trailer = nil
          context
        end
      end

      class Node < OpenStruct
        INDENT_STEP = 2

        def to_ruby(context)
          wrap_code_with_comments context do |comments_context|
            wrap_code_with_parens comments_context do |parens_context|
              to_ruby_base(parens_context)
            end
          end
        end

        def single_line_width(context)
          wrap_width_with_comments context do |comments_context|
            wrap_width_with_parens comments_context do |parens_context|
              single_line_width_base(parens_context)
            end
          end
        end

        def hates_to_stand_alone?
          false
        end

        def starts_with_comment?
          comment_before
        end

        def ends_with_comment?
          comment_after
        end

        def has_comment?
          starts_with_comment? || ends_with_comment?
        end

        def pass_trailer?
          false
        end

        def ensure_separated
          if comment_before && !comment_before.start_with?("\n")
            self.comment_before = "\n#{comment_before}"
          else
            self.comment_before = ""
          end
        end

        protected

        def indented(node, context)
          indent(node.to_ruby(context.indented(INDENT_STEP)))
        end

        def indent(s)
          s.gsub(/^(?=.)/, " " * INDENT_STEP)
        end

        def combine
          parts = []
          yield parts
          parts.join("\n")
        end

        def list(items, separator, context)
          item_shift = 0
          items.map do |item|
            item_context = context.shifted(item_shift)
            item_code    = item.to_ruby(item_context)
            item_shift  += item_code.size + separator.size
            item_code
          end.join(separator)
        end

        def wrapped_line_list(items, opener, separator, closer, context)
          combine do |parts|
            parts << opener if opener
            items[0..-2].each do |item|
              parts << "#{indented(item, context.with_trailer(separator))}"
            end
            parts << "#{indented(items.last, context)}" unless items.empty?
            parts << closer if closer
          end
        end

        def header(keyword, expression, context)
          # This whole thing is a bit hacky, but we can't help it if we don't
          # want to rewrite how |indent| and |shift| work (which we don't this
          # late).
          #
          # The basic idea is to pretend that the whole header is indented,
          # emit the expression code, and than hack the first line.

          expression_context = context.
            indented(INDENT_STEP).
            shifted(keyword.size + 1 - INDENT_STEP)
          expression_code    = indent(expression.to_ruby(expression_context))

          "#{keyword} #{expression_code[INDENT_STEP..-1]}"
        end

        def list_single_line_width(items, separator_width, context)
          items_width      = items.
            map { |i| i.single_line_width(context) }.
            reduce(0, &:+)
          separators_width = separator_width * [items.size - 1, 0].max

          items_width + separators_width
        end

        def fits_current_line?(context)
          single_line_width_base(context) <= context.width - context.shift
        end

        def enclose_in_parens?(context)
          priority < context.priority
        end

        def wrap_code_with_parens(context)
          if enclose_in_parens?(context)
            if pass_trailer?
              trailer = ")#{context.trailer}"
              "(#{yield(context.shifted(1).with_trailer(trailer))}"
            else
              "(#{yield(context.shifted(1))})"
            end
          else
            yield context
          end
        end

        def wrap_code_with_comments(context)
          code = if pass_trailer?
            yield context
          else
            "#{yield(context.without_trailer)}#{context.trailer}"
          end

          code = "#{comment_before}\n#{code}" if comment_before
          code = "#{code} #{comment_after}"   if comment_after
          code
        end

        def wrap_width_with_parens(context)
          enclose_in_parens?(context) ? 1 + yield(context) + 1 : yield(context)
        end

        def wrap_width_with_comments(context)
          width = yield(context)
          width += Float::INFINITY        if comment_before
          width += 1 + comment_after.size if comment_after
          width
        end
      end

      # ===== Statements =====

      class Program < Node
        def to_ruby(context)
          combine do |parts|
            statements_code = wrap_code_with_comments context do |comments_context|
              wrap_code_with_parens comments_context do |parens_context|
                statements.to_ruby(parens_context.with_priority(priority))
              end
            end

            parts << "# encoding: utf-8"
            parts << ""
            parts << statements_code
          end
        end

        def single_line_width_base(context)
          Float::INFINITY   # always multiline
        end

        def priority
          Priority::NONE
        end

        private

        def format_comment
          comment.gsub(/^.*$/) { |s| s.empty? ? "#" : "# #{s}" }
        end
      end

      class Class < Node
        def to_ruby_base(context)
          superclass_shift  = 6 + name.size + 3
          superclass_context = context.
            shifted(superclass_shift).
            with_priority(priority)
          superclass_code    = superclass.to_ruby(superclass_context)

          combine do |parts|
            parts << "class #{name} < #{superclass_code}"
            parts << indented(statements, context.with_priority(priority))
            parts << "end"
          end
        end

        def single_line_width_base(context)
          Float::INFINITY   # always multiline
        end

        def priority
          Priority::NONE
        end
      end

      class Module < Node
        def to_ruby_base(context)
          combine do |parts|
            parts << "module #{name}"
            parts << indented(statements, context.with_priority(priority))
            parts << "end"
          end
        end

        def single_line_width_base(context)
          Float::INFINITY   # always multiline
        end

        def priority
          Priority::NONE
        end
      end

      class Def < Node
        def to_ruby_base(context)
          args_shift   = 4 + name.size
          args_context = context.shifted(args_shift).with_priority(priority)
          args_code    = emit_args(args_context)

          combine do |parts|
            parts << "def #{name}#{args_code}"
            parts << indented(statements, context.with_priority(priority))
            parts << "end"
          end
        end

        def single_line_width_base(context)
          Float::INFINITY   # always multiline
        end

        def priority
          Priority::NONE
        end

        private

        def args_have_comments?
          args.any? { |a| a.has_comment? }
        end

        def emit_args(context)
          if !args_have_comments?
            emit_args_single_line(context)
          else
            emit_args_multi_line(context)
          end
        end

        def emit_args_single_line(context)
          if !args.empty?
            "(#{list(args, ", ", context.shifted(1))})"
          else
            ""
          end
        end

        def emit_args_multi_line(context)
          wrapped_line_list(args, "(", ",", ")", context)
        end
      end

      class Statements < Node
        def to_ruby_base(context)
          combine do |parts|
            # The |compact| call is needed because some YCP AST nodes don't
            # translate into anything, meaning their |compile| method will
            # return |nil|. These |nil|s may end up in statement lists.
            statements.compact.each do |statement|
              parts << statement.to_ruby(context.with_priority(priority))
            end
          end
        end

        def single_line_width_base(context)
          case statements.size
            when 0
              0
            when 1
              statement_context = context.with_priority(priority)

              statements.first.single_line_width(statement_context)
            else
              Float::INFINITY   # always multiline
          end
        end

        def priority
          Priority::NONE
        end

        def starts_with_comment?
          comment_before ||
            (statements.size > 0 && statements.first.starts_with_comment?)
        end

        def ends_with_comment?
          comment_after ||
            (statements.size > 0 && statements.last.ends_with_comment?)
        end
      end

      class Begin < Node
        def to_ruby_base(context)
          combine do |parts|
            parts << "begin"
            parts << indented(statements, context.with_priority(priority))
            parts << "end"
          end
        end

        def single_line_width_base(context)
          Float::INFINITY   # always multiline
        end

        def priority
          Priority::NONE
        end
      end

      class If < Node
        def to_ruby_base(context)
          if fits_current_line?(context) && !self.elsif &&
              !has_line_breaking_comment?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if !self.else && !has_line_breaking_comment?
            inner_context = context.with_priority(priority)

            then_width      = self.then.single_line_width(inner_context)
            condition_width = condition.single_line_width(inner_context)

            then_width + 4 + condition_width
          else
            Float::INFINITY
          end
        end

        def priority
          Priority::NONE
        end

        private

        def has_line_breaking_comment?
          condition.starts_with_comment? || self.then.ends_with_comment?
        end

        def to_ruby_base_single_line(context)
          then_code = self.then.to_ruby(context.with_priority(priority))

          condition_shift   = then_code.size + 4
          condition_context = context.
            shifted(condition_shift).
            with_priority(priority)
          condition_code    = condition.to_ruby(condition_context)

          "#{then_code} if #{condition_code}"
        end

        def to_ruby_base_multi_line(context)
          inner_context = context.with_priority(priority)

          combine do |parts|
            if self.elsif
              parts << header("elsif", condition, inner_context)
            else
              parts << header("if", condition, inner_context)
            end
            parts << indented(self.then, inner_context)
            if self.else
              if self.else.elsif
                parts << self.else.to_ruby(inner_context)
              else
                parts << "else"
                parts << indented(self.else, inner_context)
                parts << "end"
              end
            else
              parts << "end"
            end
          end
        end
      end

      class Unless < Node
        def to_ruby_base(context)
          if fits_current_line?(context) && !has_line_breaking_comment?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if !self.else && !has_line_breaking_comment?
            inner_context = context.with_priority(priority)

            then_width      = self.then.single_line_width(inner_context)
            condition_width = condition.single_line_width(inner_context)

            then_width + 8 + condition_width
          else
            Float::INFINITY
          end
        end

        def priority
          Priority::NONE
        end

        private

        def has_line_breaking_comment?
          condition.starts_with_comment? || self.then.ends_with_comment?
        end

        def to_ruby_base_single_line(context)
          then_code = self.then.to_ruby(context.with_priority(priority))

          condition_shift   = then_code.size + 8
          condition_context = context.
            shifted(condition_shift).
            with_priority(priority)
          condition_code    = condition.to_ruby(condition_context)

          "#{then_code} unless #{condition_code}"
        end

        def to_ruby_base_multi_line(context)
          inner_context = context.with_priority(priority)

          combine do |parts|
            parts << header("unless", condition, inner_context)
            parts << indented(self.then, inner_context)
            if self.else
              parts << "else"
              parts << indented(self.else, inner_context)
            end
            parts << "end"
          end
        end
      end

      class Case < Node
        def to_ruby_base(context)
          inner_context = context.with_priority(priority)

          combine do |parts|
            parts << header("case", expression, inner_context)
            whens.each do |whem|
              parts << indented(whem, inner_context)
            end
            parts << indented(self.else, inner_context) if self.else
            parts << "end"
          end
        end

        def single_line_width_base(context)
          Float::INFINITY   # always multiline
        end

        def priority
          Priority::NONE
        end
      end

      class When < Node
        def to_ruby_base(context)
          if !values_have_comments?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          Float::INFINITY   # always multiline
        end

        private

        def values_have_comments?
          values.any? { |v| v.has_comment? }
        end

        def to_ruby_base_single_line(context)
          values_context = context.shifted(5).with_priority(priority)

          combine do |parts|
            parts << "when #{list(values, ", ", values_context)}"
            parts << indented(body, context.with_priority(priority))
          end
        end

        def to_ruby_base_multi_line(context)
          inner_context = context.with_priority(priority)

          combine do |parts|
            parts << "when"
            parts << wrapped_line_list(values, nil, ",", nil, inner_context)
            parts << indented(body, inner_context)
          end
        end

        def priority
          Priority::NONE
        end
      end

      class Else < Node
        def to_ruby_base(context)
          combine do |parts|
            parts << "else"
            parts << indented(body, context.with_priority(priority))
          end
        end

        def single_line_width_base(context)
          Float::INFINITY   # always multiline
        end

        def priority
          Priority::NONE
        end
      end

      class While < Node
        def to_ruby_base(context)
          inner_context = context.with_priority(priority)

          if !body.is_a?(Begin)
            combine do |parts|
              parts << header("while", condition, inner_context)
              parts << indented(body, inner_context)
              parts << "end"
            end
          else
            body_code      = body.to_ruby(inner_context)
            condition_code = condition.to_ruby(inner_context)

            "#{body_code} while #{condition_code}"
          end
        end

        def single_line_width_base(context)
          Float::INFINITY   # always multiline
        end

        def priority
          Priority::NONE
        end
      end

      class Until < Node
        def to_ruby_base(context)
          inner_context = context.with_priority(priority)

          if !body.is_a?(Begin)
            combine do |parts|
              parts << header("until", condition, inner_context)
              parts << indented(body, inner_context)
              parts << "end"
            end
          else
            body_code      = body.to_ruby(inner_context)
            condition_code = condition.to_ruby(inner_context)

            "#{body_code} until #{condition_code}"
          end
        end

        def single_line_width_base(context)
          Float::INFINITY   # always multiline
        end

        def priority
          Priority::NONE
        end
      end

      class Break < Node
        def to_ruby_base(context)
          "break"
        end

        def single_line_width_base(context)
          5
        end

        def priority
          Priority::NONE
        end
      end

      class Next < Node
        def to_ruby_base(context)
          if !has_line_breaking_comment?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if !has_line_breaking_comment
            if value
              5 + value.single_line_width(context.with_priority(priority))
            else
              4
            end
          else
            Float::INFINITY
          end
        end

        private

        def has_line_breaking_comment?
          value && value.starts_with_comment?
        end

        def to_ruby_base_single_line(context)
          if value
            "next #{value.to_ruby(context.shifted(5).with_priority(priority))}"
          else
            "next"
          end
        end

        def to_ruby_base_multi_line(context)
          combine do |parts|
            parts << "next ("
            parts << indented(value, context.with_priority(priority))
            parts << ")"
          end
        end

        def priority
          Priority::NONE
        end
      end

      class Return < Node
        def to_ruby_base(context)
          if !has_line_breaking_comment?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if !has_line_breaking_comment
            if value
              7 + value.single_line_width(context.with_priority(priority))
            else
              6
            end
          else
            Float::INFINITY
          end
        end

        private

        def has_line_breaking_comment?
          value && value.starts_with_comment?
        end

        def to_ruby_base_single_line(context)
          if value
            "return #{value.to_ruby(context.shifted(7).with_priority(priority))}"
          else
            "return"
          end
        end

        def to_ruby_base_multi_line(context)
          combine do |parts|
            parts << "return ("
            parts << indented(value, context.with_priority(priority))
            parts << ")"
          end
        end

        def priority
          Priority::NONE
        end
      end

      # ===== Expressions =====

      class Expressions < Node
        def to_ruby_base(context)
          if (fits_current_line?(context) && !expressions_have_comments?) || expressions.empty?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if !expressions_have_comments?
            expressions_context = context.with_priority(Priority::NONE)

            1 + list_single_line_width(expressions, 2, expressions_context) + 1
          else
            Float::INFINITY
          end
        end

        def priority
          Priority::ATOMIC
        end

        private

        def expressions_have_comments?
          expressions_have_comments = expressions.any? { |e| e.has_comment? }
        end

        def to_ruby_base_single_line(context)
          expressions_context = context.shifted(1).with_priority(Priority::NONE)

          "(#{list(expressions, "; ", expressions_context)})"
        end

        def to_ruby_base_multi_line(context)
          expressions_context = context.with_priority(Priority::NONE)

          wrapped_line_list(expressions, "(", ";", ")", expressions_context)
        end
      end

      class Assignment < Node
        def to_ruby_base(context)
          if !has_line_breaking_comment?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if !has_line_breaking_comment?
            inner_context = context.with_priority(priority)

            lhs_width = lhs.single_line_width(inner_context)
            rhs_width = rhs.single_line_width(inner_context)

            lhs_width + 3 + rhs_width
          else
            Float::INFINITY
          end
        end

        def priority
          Priority::ASSIGNMENT
        end

        def starts_with_comment?
          comment_before || lhs.starts_with_comment?
        end

        def ends_with_comment?
          comment_after || rhs.ends_with_comment?
        end

        def pass_trailer?
          true
        end

        private

        def has_line_breaking_comment?
          lhs.ends_with_comment? || rhs.starts_with_comment?
        end

        def to_ruby_base_single_line(context)
          lhs_context = context.without_trailer.with_priority(priority)
          lhs_code    = lhs.to_ruby(lhs_context)

          rhs_shift   = lhs_code.size + 3
          rhs_context = context.shifted(rhs_shift).with_priority(priority)
          rhs_code    = rhs.to_ruby(rhs_context)

          "#{lhs_code} = #{rhs_code}"
        end

        def to_ruby_base_multi_line(context)
          lhs_context = context.with_trailer(" =").with_priority(priority)
          lhs_code    = lhs.to_ruby(lhs_context)

          rhs_context = context.with_priority(priority)
          rhs_code    = indented(rhs, rhs_context)

          combine do |parts|
            parts << lhs_code
            parts << rhs_code
          end
        end
      end

      class UnaryOperator < Node
        OPS_TO_PRIORITIES = {
          "!" => Priority::UNARY,
          "~" => Priority::UNARY,
          "+" => Priority::UNARY,
          "-" => Priority::UNARY_MINUS
        }

        def to_ruby_base(context)
          expressions_context = context.shifted(op.size).with_priority(priority)

          "#{op}#{expression.to_ruby(expressions_context)}"
        end

        def single_line_width_base(context)
          inner_context = context.with_priority(priority)

          op.size + expression.single_line_width(inner_context)
        end

        def priority
          OPS_TO_PRIORITIES[op]
        end

        def ends_with_comment?
          comment_after || expression.ends_with_comment?
        end

        def pass_trailer?
          true
        end
      end

      class BinaryOperator < Node
        OPS_TO_PRIORITIES = {
          "**"  => Priority::POWER,
          "*"   => Priority::MULTIPLY,
          "/"   => Priority::MULTIPLY,
          "%"   => Priority::MULTIPLY,
          "+"   => Priority::ADD,
          "-"   => Priority::ADD,
          "<<"  => Priority::SHIFT,
          ">>"  => Priority::SHIFT,
          "&"   => Priority::BITWISE_AND,
          "|"   => Priority::BITWISE_OR,
          "^"   => Priority::BITWISE_OR,
          ">"   => Priority::COMPARE,
          ">="  => Priority::COMPARE,
          "<"   => Priority::COMPARE,
          "<="  => Priority::COMPARE,
          "<=>" => Priority::EQUAL,
          "=="  => Priority::EQUAL,
          "===" => Priority::EQUAL,
          "!="  => Priority::EQUAL,
          "=~"  => Priority::EQUAL,
          "!~"  => Priority::EQUAL,
          "&&"  => Priority::LOGICAL_AND,
          "||"  => Priority::LOGICAL_OR,
        }

        def to_ruby_base(context)
          if (fits_current_line?(context) || rhs.hates_to_stand_alone?) &&
              !has_line_breaking_comment?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if !has_line_breaking_comment?
            inner_context = context.with_priority(priority)

            lhs_width = lhs.single_line_width(inner_context)
            rhs_width = rhs.single_line_width(inner_context)

            lhs_width + 1 + op.size + 1 + rhs_width
          else
            Float::INFINITY
          end
        end

        def priority
          OPS_TO_PRIORITIES[op]
        end

        def starts_with_comment?
          comment_before || lhs.starts_with_comment?
        end

        def ends_with_comment?
          comment_after || rhs.ends_with_comment?
        end

        def pass_trailer?
          true
        end

        protected

        def enclose_in_parens?(context)
          # YCP allows |a == b == c|, Ruby does not. We ensure |(a == b) == c|
          # gets emitted instead.
          if priority == Priority::EQUAL && context.priority == Priority::EQUAL
            true
          else
            super context
          end
        end

        private

        def has_line_breaking_comment?
          lhs.ends_with_comment? || rhs.starts_with_comment?
        end

        def to_ruby_base_single_line(context)
          lhs_context = context.without_trailer.with_priority(priority)
          lhs_code    = lhs.to_ruby(lhs_context)

          rhs_shift   = lhs_code.size + 1 + op.size + 1
          rhs_context = context.shifted(rhs_shift).with_priority(priority)
          rhs_code    = rhs.to_ruby(rhs_context)

          "#{lhs_code} #{op} #{rhs_code}"
        end

        def to_ruby_base_multi_line(context)
          lhs_context = context.with_trailer(" #{op}").with_priority(priority)
          lhs_code    = lhs.to_ruby(lhs_context)

          rhs_context = context.with_priority(priority)
          rhs_code    = indented(rhs, rhs_context)

          combine do |parts|
            parts << lhs_code
            parts << rhs_code
          end
        end
      end

      class TernaryOperator < Node
        def to_ruby_base(context)
          if (fits_current_line?(context) || (self.then.hates_to_stand_alone? && self.else.hates_to_stand_alone?)) &&
              !has_line_breaking_comment?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if !has_line_breaking_comment?
            inner_context = context.with_priority(priority)

            condition_width = condition.single_line_width(inner_context)
            then_width      = self.then.single_line_width(inner_context)
            else_width      = self.else.single_line_width(inner_context)

            condition_width + 3 + then_width + 3 + else_width
          else
            Float::INFINITY
          end
        end

        def priority
          Priority::TERNARY
        end

        def starts_with_comment?
          comment_before || condition.starts_with_comment?
        end

        def ends_with_comment?
          comment_after || self.else.ends_with_comment?
        end

        def pass_trailer?
          true
        end

        private

        def has_line_breaking_comment?
          condition.ends_with_comment? ||
            self.then.starts_with_comment? ||
            self.then.ends_with_comment? ||
            self.else.starts_with_comment?
        end

        def to_ruby_base_single_line(context)
          condition_context = context.without_trailer.with_priority(priority)
          condition_code    = condition.to_ruby(condition_context)

          then_shift   = condition_code.size + 3
          then_context = context.
            shifted(then_shift).
            without_trailer.
            with_priority(priority)
          then_code    = self.then.to_ruby(then_context)

          else_shift   = then_shift + then_code.size + 3
          else_context = context.shifted(else_shift).with_priority(priority)
          else_code    = self.else.to_ruby(else_context)

          "#{condition_code} ? #{then_code} : #{else_code}"
        end

        def to_ruby_base_multi_line(context)
          condition_context = context.with_trailer(" ?").with_priority(priority)
          condition_code    = condition.to_ruby(condition_context)

          then_context = context.with_trailer(" :").with_priority(priority)
          then_code    = indented(self.then, then_context)

          else_context = context.with_priority(priority)
          else_code    = indented(self.else, else_context)

          combine do |parts|
            parts << condition_code
            parts << then_code
            parts << else_code
          end
        end
      end

      class MethodCall < Node
        def to_ruby_base(context)
          # The algorithm for deciding whether the call should be split into
          # multile lines is based on seeing if the arguments fit into the
          # current line. That means we ignore the block part. This could lead
          # to some cases where a block starts beyond the right margin (when the
          # arguments fit, but just barely). I decided to ignore these cases, as
          # their impact on readability is minimal and handling them would
          # complicate already complex code.

          receiver_context = context.with_trailer(".").with_priority(Priority::ATOMIC)
          receiver_code    = receiver ? "#{receiver.to_ruby(receiver_context)}" : ""

          if has_line_breaking_comment?
            context = context.indented(INDENT_STEP)
          end

          args_shift   = receiver_code.size + name.size
          args_context = context.
            shifted(args_shift).
            without_trailer.
            with_priority(Priority::NONE)
          args_code    = emit_args(context, args_context)

          if Code.multi_line?(args_code)
            block_context = context.shifted(1).with_priority(Priority::NONE)
          else
            block_shift   = args_shift + args_code.size
            block_context = context.
              shifted(block_shift).
              with_priority(Priority::NONE)
          end
          block_code    = block ? " #{block.to_ruby(block_context)}" : ""

          if !has_line_breaking_comment?
            "#{receiver_code}#{name}#{args_code}#{block_code}"
          else
            combine do |parts|
              parts << receiver_code
              parts << indent("#{name}#{args_code}#{block_code}")
            end
          end
        end

        def single_line_width_base(context)
          if !has_line_breaking_comment? && !args_have_comments?
            receiver_context = context.with_priority(Priority::ATOMIC)
            receiver_width   = if receiver
              receiver.single_line_width(receiver_context) + 1
            else
              0
            end

            args_context = context.with_priority(Priority::NONE)
            args_width   = args_single_line_width(args_context)

            receiver_width + name.size + args_width
          else
            Float::INFINITY
          end
        end

        def priority
          parens ? Priority::ATOMIC : Priority::NONE
        end

        def starts_with_comment?
          if parens
            comment_before || (receiver && receiver.starts_with_comment?)
          else
            comment_before   # Ignore deep comments, like we do for statements.
          end
        end

        def ends_with_comment?
          if parens
            comment_after || (block && block.ends_with_comment?)
          else
            comment_after   # Ignore deep comments, like we do for statements.
          end
        end

        def pass_trailer?
          if parens
            block
          else
            false    # Ignore deep comments, like we do for statements.
          end
        end

        private

        def has_line_breaking_comment?
          receiver && receiver.ends_with_comment?
        end

        def args_have_comments?
          args.any? { |a| a.has_comment? }
        end

        def emit_args(context, args_context)
          if (fits_current_line?(context) && !args_have_comments?) || !parens
            emit_args_single_line(args_context)
          else
            emit_args_multi_line(args_context)
          end
        end

        def emit_args_single_line(context)
          if !args.empty?
            arg_context = context.without_max_key_width

            if parens
              "(#{list(args, ", ", arg_context)})"
            else
              " #{list(args, ", ", arg_context)}"
            end
          else
            !receiver && name =~ /^[A-Z]/ && args.empty? ? "()" : ""
          end
        end

        def emit_args_multi_line(context)
          entries = args.select { |a| a.is_a?(HashEntry) }

          if !entries.empty?
            max_key_width = entries.map do |entry|
              entry.key_width(context.indented(INDENT_STEP))
            end.max

            arg_context = context.with_max_key_width(max_key_width)
          else
            arg_context = context.without_max_key_width
          end

          wrapped_line_list(args, "(", ",", ")", arg_context)
        end

        def args_single_line_width(context)
          if !args.empty?
            if parens
              1 + list_single_line_width(args, 2, context) + 1
            else
              1 + list_single_line_width(args, 2, context)
            end
          else
            !receiver && name =~ /^[A-Z]/ && args.empty? ? 2 : 0
          end
        end
      end

      class Block < Node
        def to_ruby_base(context)
          if fits_current_line?(context) && !args_have_comments?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if !args_have_comments?
            args_context = context.with_priority(Priority::NONE)
            args_width   = list_single_line_width(args, 2, args_context)

            statements_context = context.with_priority(Priority::NONE)
            statements_width   = statements.single_line_width(statements_context)

            if !args.empty?
              3 + args_width + 2 + statements_width + 2
            else
              2 + statements_width + 2
            end
          else
            Float::INFINITY
          end
        end

        def priority
          Priority::ATOMIC
        end

        private

        def args_have_comments?
          args.any? { |a| a.has_comment? }
        end

        def to_ruby_base_single_line(context)
          args_context = context.shifted(1).with_priority(Priority::NONE)
          args_code    = emit_args(args_context)

          statements_shift   = 1 + args_code.size + 1
          statements_context = context.
            shifted(statements_shift).
            with_priority(Priority::NONE)
          statements_code    = statements.to_ruby(statements_context)

          "{#{args_code} #{statements_code} }"
        end

        def to_ruby_base_multi_line(context)
          args_context = context.shifted(2).with_priority(Priority::NONE)
          args_code = emit_args(args_context)

          combine do |parts|
            parts << "do#{args_code}"
            parts << indented(statements, context.with_priority(Priority::NONE))
            parts << "end"
          end
        end

        def emit_args(context)
          if !args_have_comments?
            emit_args_single_line(context)
          else
            emit_args_multi_line(context)
          end
        end

        def emit_args_single_line(context)
          if !args.empty?
            " |#{list(args, ", ", context.shifted(2))}|"
          else
            ""
          end
        end

        def emit_args_multi_line(context)
          wrapped_line_list(args, " |", ",", "|", context)
        end
      end

      class ConstAccess < Node
        def to_ruby_base(context)
          if !has_line_breaking_comment?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if receiver
            if !has_line_breaking_comment?
              receiver_context = context.with_priority(priority)

              receiver.single_line_width(receiver_context) + 2 + name.size
            else
              Float::INFINITY
            end
          else
            name.size
          end
        end

        def priority
          Priority::ATOMIC
        end

        def starts_with_comment?
          comment_before || (receiver && receiver.starts_with_comment?)
        end

        private

        def has_line_breaking_comment?
          receiver && receiver.ends_with_comment?
        end

        def to_ruby_base_single_line(context)
          if receiver
            "#{receiver.to_ruby(context.with_priority(priority))}::#{name}"
          else
            name
          end
        end

        def to_ruby_base_multi_line(context)
          receiver_context = context.with_trailer("::").with_priority(priority)
          receiver_code    = receiver.to_ruby(receiver_context)

          combine do |parts|
            parts << receiver_code
            parts << indent(name)
          end
        end
      end

      class Variable < Node
        def to_ruby_base(context)
          name
        end

        def single_line_width_base(context)
          name.size
        end

        def priority
          Priority::ATOMIC
        end

        def hates_to_stand_alone?
          true
        end
      end

      class Self < Node
        def to_ruby_base(context)
          "self"
        end

        def single_line_width_base(context)
          4
        end

        def priority
          Priority::ATOMIC
        end

        def hates_to_stand_alone?
          true
        end
      end

      # ===== Literals =====

      class Literal < Node
        def to_ruby_base(context)
          if is_long_multi_line_string?
            combine do |parts|
              lines = value.lines.to_a

              parts << "#{lines.first.inspect} +"
              lines[1..-2].each do |line|
                parts << indent("#{line.inspect} +")
              end
              parts << indent("#{lines.last.inspect}")
            end
          else
            value.inspect
          end
        end

        def single_line_width_base(context)
          if is_long_multi_line_string?
            Float::INFINITY
          else
            value.inspect.size
          end
        end

        def priority
          if is_long_multi_line_string?
            Priority::ADD
          else
            Priority::ATOMIC
          end
        end

        def hates_to_stand_alone?
          if value.is_a?(String) || value.is_a?(Symbol)
            value.size <= 16
          else
            true
          end
        end

        private

        def is_long_multi_line_string?
          value.is_a?(String) && value.size > 40 && value.lines.count > 2
        end
      end

      class Array < Node
        def to_ruby_base(context)
          if (fits_current_line?(context) && !elements_have_comments?) || elements.empty?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if !elements_have_comments?
            elements_context = context.with_priority(Priority::NONE)

            1 + list_single_line_width(elements, 2, elements_context) + 1
          else
            Float::INFINITY
          end
        end

        def priority
          Priority::ATOMIC
        end

        def hates_to_stand_alone?
          elements.empty?
        end

        private

        def elements_have_comments?
          elements.any? { |e| e.has_comment? }
        end

        def to_ruby_base_single_line(context)
          elements_context = context.shifted(1).with_priority(Priority::NONE)

          "[#{list(elements, ", ", elements_context)}]"
        end

        def to_ruby_base_multi_line(context)
          elements_context = context.with_priority(Priority::NONE)

          wrapped_line_list(elements, "[", ",", "]", elements_context)
        end
      end

      class Hash < Node
        def to_ruby_base(context)
          if (fits_current_line?(context) && !entries_have_comments?) || entries.empty?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if !entries.empty?
            if !entries_have_comments?
              entries_context = context.with_priority(Priority::NONE)

              2 + list_single_line_width(entries, 2, entries_context) + 2
            else
              Float::INFINITY
            end
          else
            2
          end
        end

        def priority
          Priority::ATOMIC
        end

        def hates_to_stand_alone?
          entries.empty?
        end

        private

        def entries_have_comments?
          entries.any? { |e| e.has_comment? }
        end

        def to_ruby_base_single_line(context)
          entry_context = context.
            shifted(2).
            with_priority(Priority::NONE).
            without_max_key_width

          if !entries.empty?
            "{ #{list(entries, ", ", entry_context)} }"
          else
            "{}"
          end
        end

        def to_ruby_base_multi_line(context)
          max_key_width = entries.map do |entry|
            entry.key_width(context.indented(INDENT_STEP))
          end.max

          entry_context = context.
            with_priority(Priority::NONE).
            with_max_key_width(max_key_width)

          wrapped_line_list(entries, "{", ",", "}", entry_context)
        end
      end

      class HashEntry < Node
        def to_ruby_base(context)
          if !has_line_breaking_comment?
            to_ruby_base_single_line(context)
          else
            to_ruby_base_multi_line(context)
          end
        end

        def single_line_width_base(context)
          if !has_line_breaking_comment?
            inner_context = context.with_priority(Priority::NONE)

            key_width   = key.single_line_width(inner_context)
            value_width = value.single_line_width(inner_context)

            key_width + 4 + value_width
          else
            Float::INFINITY
          end
        end

        def priority
          Priority::ATOMIC
        end

        def starts_with_comment?
          comment_before || key.starts_with_comment?
        end

        def ends_with_comment?
          comment_after || value.ends_with_comment?
        end

        def pass_trailer?
          true
        end

        def key_width(context)
          key.to_ruby_base(context).split("\n").last.size
        end

        private

        def has_line_breaking_comment?
          key.ends_with_comment? || value.starts_with_comment?
        end

        def to_ruby_base_single_line(context)
          key_context = context.without_trailer.with_priority(Priority::NONE)
          key_code    = key.to_ruby(key_context)

          spacing_code = if context.max_key_width
            " " * (context.max_key_width - key_width(context))
          else
            ""
          end

          value_shift   = key_code.size + spacing_code.size + 4
          value_context = context.
            shifted(value_shift).
            with_priority(Priority::NONE)
          value_code    = value.to_ruby(value_context)

          "#{key_code}#{spacing_code} => #{value_code}"
        end

        def to_ruby_base_multi_line(context)
          key_context = context.
            with_trailer("#{spacing_code} =>").
            with_priority(Priority::NONE)
          key_code    = key.to_ruby(key_context)

          spacing_code = if context.max_key_width
            " " * (context.max_key_width - key_width(context))
          else
            ""
          end

          value_context = context.with_priority(Priority::NONE)
          value_code    = indented(value, value_context)

          combine do |parts|
            parts << key_code
            parts << value_code
          end
        end
      end
    end
  end
end
